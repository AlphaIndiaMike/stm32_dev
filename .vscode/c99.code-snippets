{
    "Complete C Module Header": {
        "prefix": "cmodh",
        "description": "Create a complete C module header file",
        "body": [
            "/**",
            " * @file ${TM_FILENAME}",
            " * @brief ${2:Module description}",
            " * @author ${3:Your Name}",
            " * @date ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
            " * @version ${4:1.0}",
            " * ",
            " * @copyright Copyright (c) ${CURRENT_YEAR}",
            " * @license ${5:MIT License}",
            " */",
            "",
            "#ifndef ${TM_FILENAME_BASE/(.*)/${1:/upcase}_H/}",
            "#define ${TM_FILENAME_BASE/(.*)/${1:/upcase}_H/}",
            "",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "",
            "/* Error codes */",
            "typedef enum {",
            "    ${TM_FILENAME_BASE/(.*)/${1:/upcase}/}_SUCCESS = 0,",
            "    ${TM_FILENAME_BASE/(.*)/${1:/upcase}/}_ERROR_NULL_POINTER = -1,",
            "    ${TM_FILENAME_BASE/(.*)/${1:/upcase}/}_ERROR_INVALID_PARAM = -2,",
            "    ${TM_FILENAME_BASE/(.*)/${1:/upcase}/}_ERROR_MEMORY = -3",
            "} ${TM_FILENAME_BASE}_error_t;",
            "",
            "/* Opaque handle type */",
            "typedef struct ${TM_FILENAME_BASE}_ctx_s* ${TM_FILENAME_BASE}_handle_t;",
            "",
            "/* Configuration structure */",
            "typedef struct {",
            "    size_t max_items;",
            "    bool thread_safe;",
            "    void* user_data;",
            "} ${TM_FILENAME_BASE}_config_t;",
            "",
            "/* Public API functions */",
            "",
            "/**",
            " * @brief Initialize the module with given configuration",
            " * ",
            " * @param[out] handle Pointer to store the created handle",
            " * @param[in] config Configuration parameters",
            " * @return ${TM_FILENAME_BASE}_error_t Error code",
            " */",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_init(${TM_FILENAME_BASE}_handle_t* handle, const ${TM_FILENAME_BASE}_config_t* config);",
            "",
            "/**",
            " * @brief Process data using the module",
            " * ",
            " * @param[in] handle Module handle",
            " * @param[in] data Input data",
            " * @param[in] size Size of input data",
            " * @param[out] result Processed result",
            " * @return ${TM_FILENAME_BASE}_error_t Error code",
            " */",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_process(${TM_FILENAME_BASE}_handle_t handle,",
            "                       const void* data,",
            "                       size_t size,",
            "                       void* result);",
            "",
            "/**",
            " * @brief Clean up and destroy the module instance",
            " * ",
            " * @param[in] handle Module handle to destroy",
            " * @return ${TM_FILENAME_BASE}_error_t Error code",
            " */",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_destroy(${TM_FILENAME_BASE}_handle_t handle);",
            "",
            "/**",
            " * @brief Get the last error message",
            " * ",
            " * @return const char* Error message string",
            " */",
            "const char* ${TM_FILENAME_BASE}_get_error_string(void);",
            "",
            "/**",
            " * @brief Get the module version",
            " * ",
            " * @return const char* Version string",
            " */",
            "const char* ${TM_FILENAME_BASE}_get_version(void);",
            "",
            "#endif /* ${TM_FILENAME_BASE/(.*)/${1:/upcase}_H/} */",
            ""
        ]
    },
    "Complete C Module Implementation": {
        "prefix": "cmodi",
        "description": "Create a complete C module implementation file",
        "body": [
            "/**",
            " * @file ${TM_FILENAME}",
            " * @brief Implementation of the module functionality",
            " */",
            "",
            "#include \"${TM_FILENAME_BASE}.h\"",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <pthread.h>",
            "",
            "#define ${TM_FILENAME_BASE/(.*)/${1:/upcase}_VERSION/} \"${2:1.0.0}\"",
            "#define MAX_ERROR_MSG_LEN 256",
            "",
            "/* Private structure definitions */",
            "struct ${TM_FILENAME_BASE}_ctx_s {",
            "    ${TM_FILENAME_BASE}_config_t config;",
            "    void* internal_data;",
            "    pthread_mutex_t mutex;",
            "    bool initialized;",
            "};",
            "",
            "/* Static variables */",
            "static char last_error[MAX_ERROR_MSG_LEN] = {0};",
            "",
            "/* Private function prototypes */",
            "static void set_error(const char* message);",
            "static bool validate_config(const ${TM_FILENAME_BASE}_config_t* config);",
            "static void cleanup_internal_data(struct ${TM_FILENAME_BASE}_ctx_s* ctx);",
            "",
            "/* Public function implementations */",
            "",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_init(${TM_FILENAME_BASE}_handle_t* handle, const ${TM_FILENAME_BASE}_config_t* config) {",
            "    if (!handle || !config) {",
            "        set_error(\"Null pointer provided\");",
            "        return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_POINTER/};",
            "    }",
            "",
            "    if (!validate_config(config)) {",
            "        set_error(\"Invalid configuration\");",
            "        return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_INVALID_PARAM/};",
            "    }",
            "",
            "    struct ${TM_FILENAME_BASE}_ctx_s* ctx = calloc(1, sizeof(struct ${TM_FILENAME_BASE}_ctx_s));",
            "    if (!ctx) {",
            "        set_error(\"Memory allocation failed\");",
            "        return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_MEMORY/};",
            "    }",
            "",
            "    /* Initialize context */",
            "    memcpy(&ctx->config, config, sizeof(${TM_FILENAME_BASE}_config_t));",
            "    ",
            "    if (config->thread_safe) {",
            "        if (pthread_mutex_init(&ctx->mutex, NULL) != 0) {",
            "            free(ctx);",
            "            set_error(\"Mutex initialization failed\");",
            "            return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_MEMORY/};",
            "        }",
            "    }",
            "",
            "    ctx->initialized = true;",
            "    *handle = ctx;",
            "    ",
            "    return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/};",
            "}",
            "",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_process(${TM_FILENAME_BASE}_handle_t handle,",
            "                       const void* data,",
            "                       size_t size,",
            "                       void* result) {",
            "    if (!handle || !data || !result) {",
            "        set_error(\"Null pointer provided\");",
            "        return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_POINTER/};",
            "    }",
            "",
            "    struct ${TM_FILENAME_BASE}_ctx_s* ctx = (struct ${TM_FILENAME_BASE}_ctx_s*)handle;",
            "    ",
            "    if (!ctx->initialized) {",
            "        set_error(\"Module not initialized\");",
            "        return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_INVALID_PARAM/};",
            "    }",
            "",
            "    ${TM_FILENAME_BASE}_error_t ret = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/};",
            "",
            "    /* Thread safety handling */",
            "    if (ctx->config.thread_safe) {",
            "        pthread_mutex_lock(&ctx->mutex);",
            "    }",
            "",
            "    /* Process the data here */",
            "    // TODO: Implement actual processing logic",
            "",
            "    if (ctx->config.thread_safe) {",
            "        pthread_mutex_unlock(&ctx->mutex);",
            "    }",
            "",
            "    return ret;",
            "}",
            "",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_destroy(${TM_FILENAME_BASE}_handle_t handle) {",
            "    if (!handle) {",
            "        set_error(\"Null handle provided\");",
            "        return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_POINTER/};",
            "    }",
            "",
            "    struct ${TM_FILENAME_BASE}_ctx_s* ctx = (struct ${TM_FILENAME_BASE}_ctx_s*)handle;",
            "    ",
            "    if (ctx->config.thread_safe) {",
            "        pthread_mutex_destroy(&ctx->mutex);",
            "    }",
            "",
            "    cleanup_internal_data(ctx);",
            "    free(ctx);",
            "",
            "    return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/};",
            "}",
            "",
            "const char* ${TM_FILENAME_BASE}_get_error_string(void) {",
            "    return last_error;",
            "}",
            "",
            "const char* ${TM_FILENAME_BASE}_get_version(void) {",
            "    return ${TM_FILENAME_BASE/(.*)/${1:/upcase}_VERSION/};",
            "}",
            "",
            "/* Private function implementations */",
            "",
            "static void set_error(const char* message) {",
            "    if (message) {",
            "        strncpy(last_error, message, MAX_ERROR_MSG_LEN - 1);",
            "        last_error[MAX_ERROR_MSG_LEN - 1] = '\\0';",
            "    } else {",
            "        last_error[0] = '\\0';",
            "    }",
            "}",
            "",
            "static bool validate_config(const ${TM_FILENAME_BASE}_config_t* config) {",
            "    if (config->max_items == 0) {",
            "        return false;",
            "    }",
            "    return true;",
            "}",
            "",
            "static void cleanup_internal_data(struct ${TM_FILENAME_BASE}_ctx_s* ctx) {",
            "    if (ctx && ctx->internal_data) {",
            "        free(ctx->internal_data);",
            "        ctx->internal_data = NULL;",
            "    }",
            "}",
            ""
        ]
    },
    "Simplified C Module Header": {
        "prefix": "cmodhs",
        "description": "Create a simplified C module header file with learning comments (MISRA compliant)",
        "body": [
            "/**",
            " * @file ${TM_FILENAME}",
            " * @brief ${2:Brief description}",
            " */",
            "",
            "#ifndef ${TM_FILENAME_BASE/(.*)/${1:/upcase}_H/}",
            "#define ${TM_FILENAME_BASE/(.*)/${1:/upcase}_H/}",
            "",
            "/* Step 1: Required Headers",
            " * TODO: Add only the headers you need",
            " * Common ones: stddef.h, stdbool.h, stdint.h",
            " */",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <stdint.h>",
            "",
            "/* Step 2: Error Codes",
            " * TODO: Define your error codes here",
            " * - Use a specific integer type for size and signedness",
            " * - Use explicit values for all enumerators",
            " * - Follow MISRA naming conventions",
            " */",
            "typedef int32_t ${TM_FILENAME_BASE}_error_t;",
            "",
            "/* Error code definitions",
            " * Note: Using #define for MISRA compliance instead of enum",
            " * - Explicit type through typedef",
            " * - Explicit values for all constants",
            " */",
            "#define ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/}          ((${TM_FILENAME_BASE}_error_t)0)",
            "#define ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_PTR/}   ((${TM_FILENAME_BASE}_error_t)1)",
            "#define ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_INVALID/}    ((${TM_FILENAME_BASE}_error_t)2)",
            "#define ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_MEMORY/}     ((${TM_FILENAME_BASE}_error_t)3)",
            "/* TODO: Add more error codes as needed */",
            "",
            "/* Step 3: Opaque Handle",
            " * TODO: This hides implementation details",
            " * - Implementation goes in .c file",
            " * - Users only see the pointer",
            " */",
            "typedef struct ${TM_FILENAME_BASE}_ctx_s* ${TM_FILENAME_BASE}_handle_t;",
            "",
            "/* Step 4: Configuration",
            " * TODO: Add your configuration options",
            " * - Group related settings",
            " * - Use appropriate types",
            " * - Document each field",
            " */",
            "typedef struct",
            "{",
            "    size_t max_items;     /* Maximum items to process */",
            "    bool_t debug_mode;    /* Enable debug output */",
            "    /* Add your config options here */",
            "} ${TM_FILENAME_BASE}_config_t;",
            "",
            "/* Step 5: Public API",
            " * TODO: Define your public functions",
            " * - Keep the interface minimal",
            " * - Use consistent naming",
            " * - Document parameters and returns",
            " */",
            "",
            "/**",
            " * Initialize the module",
            " * TODO: Document parameters and behavior",
            " * @param[out] handle Pointer to store the created handle",
            " * @param[in] config Pointer to configuration structure",
            " * @return Error code indicating success or failure",
            " */",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_init(${TM_FILENAME_BASE}_handle_t* const handle, ",
            "                      const ${TM_FILENAME_BASE}_config_t* const config);",
            "",
            "/**",
            " * Process data",
            " * TODO: Add your core functionality",
            " * @param[in] handle Module handle",
            " * @param[in] input Input data pointer",
            " * @param[out] output Output data pointer",
            " * @return Error code indicating success or failure",
            " */",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_process(const ${TM_FILENAME_BASE}_handle_t handle,",
            "                         const void* const input,",
            "                         void* const output);",
            "",
            "/**",
            " * Cleanup resources",
            " * TODO: Ensure all resources are freed",
            " * @param[in] handle Module handle to destroy",
            " * @return Error code indicating success or failure",
            " */",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_destroy(${TM_FILENAME_BASE}_handle_t handle);",
            "",
            "#endif /* ${TM_FILENAME_BASE/(.*)/${1:/upcase}_H/} */",
            ""
        ]
    },
    "Simplified C Module Implementation": {
        "prefix": "cmodis",
        "description": "Create a simplified C module implementation file with learning comments (MISRA compliant)",
        "body": [
            "/**",
            " * @file ${TM_FILENAME}",
            " * @brief Implementation of the module functionality",
            " */",
            "",
            "/* Step 1: Include Headers",
            " * TODO: Add required headers",
            " * - Module header first",
            " * - Then standard libraries",
            " * - Then other dependencies",
            " */",
            "#include \"${TM_FILENAME_BASE}.h\"",
            "#include <stddef.h>",
            "#include <stdint.h>",
            "#include <stdlib.h>",
            "",
            "/* Step 2: Constants and Macros",
            " * TODO: Define your constants",
            " * - Use static const for MISRA compliance",
            " * - Document magic numbers",
            " * - Consider configuration options",
            " */",
            "static const size_t MAX_BUFFER_SIZE = 1024U;  /* Example constant */",
            "",
            "/* Step 3: Internal Structure",
            " * TODO: Define your context structure",
            " * - Add required fields",
            " * - Group related data",
            " * - Consider alignment requirements",
            " */",
            "struct ${TM_FILENAME_BASE}_ctx_s",
            "{",
            "    ${TM_FILENAME_BASE}_config_t config;          /* Configuration copy */",
            "    uint8_t* buffer;               /* Internal buffer */",
            "    size_t buffer_size;            /* Current buffer size */",
            "    bool_t is_initialized;         /* Initialization flag */",
            "    /* TODO: Add your internal state here */",
            "};",
            "",
            "/* Step 4: Static Function Prototypes",
            " * TODO: Add helper functions",
            " * - Declare before use (MISRA)",
            " * - Document parameters",
            " * - Consider error handling",
            " */",
            "static ${TM_FILENAME_BASE}_error_t validate_config(const ${TM_FILENAME_BASE}_config_t* const config);",
            "static void cleanup_context(struct ${TM_FILENAME_BASE}_ctx_s* const ctx);",
            "",
            "/* Step 5: Static Function Implementations */",
            "static ${TM_FILENAME_BASE}_error_t validate_config(const ${TM_FILENAME_BASE}_config_t* const config)",
            "{",
            "    ${TM_FILENAME_BASE}_error_t result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/};",
            "    ",
            "    if (NULL == config)",
            "    {",
            "        result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_PTR/};",
            "    }",
            "    else if (0U == config->max_items)",
            "    {",
            "        result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_INVALID/};",
            "    }",
            "    else",
            "    {",
            "        /* Configuration is valid */",
            "    }",
            "    ",
            "    return result;",
            "}",
            "",
            "static void cleanup_context(struct ${TM_FILENAME_BASE}_ctx_s* const ctx)",
            "{",
            "    if (NULL != ctx)",
            "    {",
            "        free(ctx->buffer);",
            "        ctx->buffer = NULL;",
            "        ctx->is_initialized = false;",
            "    }",
            "}",
            "",
            "/* Step 6: Public Function Implementations */",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_init(${TM_FILENAME_BASE}_handle_t* const handle,",
            "                      const ${TM_FILENAME_BASE}_config_t* const config)",
            "{",
            "    ${TM_FILENAME_BASE}_error_t result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/};",
            "    struct ${TM_FILENAME_BASE}_ctx_s* ctx = NULL;",
            "",
            "    /* Parameter validation */",
            "    if ((NULL == handle) || (NULL == config))",
            "    {",
            "        result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_PTR/};",
            "    }",
            "    else",
            "    {",
            "        /* Validate configuration */",
            "        result = validate_config(config);",
            "        ",
            "        if (${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/} == result)",
            "        {",
            "            /* Allocate context */",
            "            ctx = (struct ${TM_FILENAME_BASE}_ctx_s*)malloc(sizeof(struct ${TM_FILENAME_BASE}_ctx_s));",
            "            if (NULL == ctx)",
            "            {",
            "                result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_MEMORY/};",
            "            }",
            "            else",
            "            {",
            "                /* Initialize context */",
            "                ctx->buffer = NULL;",
            "                ctx->buffer_size = 0U;",
            "                ctx->is_initialized = true;",
            "                ctx->config = *config;",
            "                ",
            "                *handle = ctx;",
            "            }",
            "        }",
            "    }",
            "    ",
            "    return result;",
            "}",
            "",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_process(const ${TM_FILENAME_BASE}_handle_t handle,",
            "                         const void* const input,",
            "                         void* const output)",
            "{",
            "    ${TM_FILENAME_BASE}_error_t result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/};",
            "    const struct ${TM_FILENAME_BASE}_ctx_s* const ctx = (const struct ${TM_FILENAME_BASE}_ctx_s*)handle;",
            "",
            "    /* Parameter validation */",
            "    if ((NULL == handle) || (NULL == input) || (NULL == output))",
            "    {",
            "        result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_PTR/};",
            "    }",
            "    else if (false == ctx->is_initialized)",
            "    {",
            "        result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_INVALID/};",
            "    }",
            "    else",
            "    {",
            "        /* TODO: Add processing logic here */",
            "    }",
            "",
            "    return result;",
            "}",
            "",
            "${TM_FILENAME_BASE}_error_t ${TM_FILENAME_BASE}_destroy(${TM_FILENAME_BASE}_handle_t handle)",
            "{",
            "    ${TM_FILENAME_BASE}_error_t result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_SUCCESS/};",
            "    struct ${TM_FILENAME_BASE}_ctx_s* ctx = (struct ${TM_FILENAME_BASE}_ctx_s*)handle;",
            "",
            "    if (NULL == handle)",
            "    {",
            "        result = ${TM_FILENAME_BASE/(.*)/${1:/upcase}_ERROR_NULL_PTR/};",
            "    }",
            "    else",
            "    {",
            "        cleanup_context(ctx);",
            "        free(ctx);",
            "    }",
            "",
            "    return result;",
            "}",
            ""
        ]
    }    
}